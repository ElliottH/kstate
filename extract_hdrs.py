#!/usr/bin/env python

"""extract_hdrs.py -- Extract "extern" function headers from .c files to .h files.

Usage:
            ./extract_hdrs.py  [-h | -help | --help]
            ./extract_hdrs.py  -kstate
            ./extract_hdrs.py  [<c_file> <h_file> ...]

If run with the '-kstate' switch, then it looks for the file 'kstate.c',
and writes header information to 'kstate.h'. This is for convenience in the
management of libkstate.

If run with no filenames, it looks for all the C files in the current directory,
and for each <name>.c file expects to extract headers to a corresponding
<name>_fns.h file.

Otherwise, it expects pairs of source .c file and target .h file.

In all cases, the target .h file must (a) exist and (b) contain a pair of
start/end delimiters - as, for instance::

    Any text before the first delimiter is not altered
    // -------- TEXT AFTER THIS AUTOGENERATED - DO NOT EDIT --------
    Any text in here is replaced with the (new) header text
    // -------- TEXT BEFORE THIS AUTOGENERATED - DO NOT EDIT --------
    Any text after the second delimiter is not altered

A very simple regular expression is used to detect headers - basically, the
header is from the opening ``/*`` to the ``)`` before the ``{`` in something
like::

    /*
     * Header comment text
     */
    extern datatype other words function_name( any arguments )
    {

(and in general whitespace should be flexible in the actual function signature
itself).

Beware that the script does not check to see if the output header file will be
given different content (apart from the timestamp) and will thus proceed
regardless.
"""

# ***** BEGIN LICENSE BLOCK *****
# Version: MPL 1.1
#
# The contents of this file are subject to the Mozilla Public License Version
# 1.1 (the "License"); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# for the specific language governing rights and limitations under the
# License.
#
# The Original Code is the Kynesim state management library.
#
# The Initial Developer of the Original Code is Kynesim, Cambridge UK.
# Portions created by the Initial Developer are Copyright (C) 2012
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Kynesim, Cambridge UK
#   Tony Ibbs <tibs@tonyibbs.co.uk>
#
# ***** END LICENSE BLOCK *****

import os
import re
import sys

from datetime import datetime

pattern = r"""\
(?P<header>                     # start of header group
     \s* / \* .* \n             # start of header comment
    (\s*   \* .* \n)*           # 0 or more comment lines
     \s*   \* /  \n             # end of header comment
     \s* extern \s+
        (?P<type>               # crudely allow for type info
          #(\w+ \s+) |                  # e.g., "fred "
          (\w+ \s+ \** \s*) |           # e.g., "fred *"
          (\w+ \s+ \w+ \s+ \** \s*)     # e.g., "struct fred " or "struct fred *"
        )
        (?P<name>
            \w+                 # name of function
        )
     \(  ([^)]|\n)* \)          # crudely match arguments
)                               # end of header group
\s* \n
\s* {
"""

start_delimiter = "// -------- TEXT AFTER THIS AUTOGENERATED - DO NOT EDIT --------\n"
start_timestamp = "// Autogenerated by extract_hdrs.py on %s"
end_delimiter = "// -------- TEXT BEFORE THIS AUTOGENERATED - DO NOT EDIT --------\n"

def process_file(c_file, h_file):
    """Extract header comments/prototypes from 'c_file' into 'h_file'.
    """
    temp_file = h_file + '.new'
    save_file = h_file + '.bak'

    print 'Extracting headers from %s to %s'%(c_file, h_file)

    with open(c_file,'r') as file:
        data = file.read()

        parts = re.finditer(pattern, data, re.VERBOSE)

        with open(h_file, 'r') as original:

            data = original.read()

            delimiter1_posn = data.find(start_delimiter)
            delimiter2_posn = data.find(end_delimiter)

            if delimiter1_posn == -1:
                print "Couldn't find start 'AUTOGENERATED' line in file %s"%h_file
                return

            if delimiter2_posn == -1:
                print "Couldn't find end 'AUTOGENERATED' line in file %s"%h_file
                return

            if False:
                print '-----------------------------'
                print data[:delimiter1_posn]
                print '-----------------------------'
                print data[delimiter2_posn:]
                print '-----------------------------'

            with open(temp_file, 'w') as output:

                output.write(data[:delimiter1_posn])
                # The start delimiter is in the text we decided to throw
                # away, so we need to write it out again
                output.write(start_delimiter)
                now = datetime.now()
                timestamp_str = now.strftime('%Y-%m-%d (%a %d %b %Y) at %H:%M')
                output.write(start_timestamp%timestamp_str)

                for part in parts:
                    print 'Found ',part.group('name')
                    output.write(part.group('header'))
                    output.write(';\n')

                # The end delimiter is in the text we decided to keep,
                # so we don't need to write it out again
                output.write('\n')
                output.write(data[delimiter2_posn:])

        os.rename(h_file, save_file)
        os.rename(temp_file, h_file)

def do_stuff(args):

    c_to_h = {}

    if not args:
        filenames = os.listdir('.')
        for name in filenames:
            base, ext = os.path.splitext(name)
            if ext == '.c':
                c_to_h[name] = '%s_fns.h'%base
    else:
        while len(args) > 0:
            word = args[0]
            args = args[1:]
            if word in ('-help', '-h', '--help'):
                print __doc__
                return
            elif word == '-kstate':
                c_to_h = {'kstate.c' : 'kstate.h'}
                if len(args[1:]) != 0:
                    print 'Unexpected arguments %s after -kstate'%args[1:]
                    return
            else:
                c_file = word
                try:
                    h_file = args[0]
                except:
                    print 'C file (%s) not matched to a .h file'%c_file
                    return
                c_to_h[c_file] = h_file
                args = args[1:]
                if len(args) %2 != 0:
                    print 'Unbalanced arguments: not pairs of c_file h_file'

    # Basic checks before we do *anything*
    for c_file, h_file in c_to_h.items():
        if not os.path.exists(c_file):
            print 'C source file %s does not exist'%c_file
            return
        if not os.path.exists(h_file):
            print 'C header file %s does not exist'%h_file
            return
        if os.path.splitext(c_file)[-1] != '.c':
            print 'C source file %s does not have extension .c'%c_file
            return
        if os.path.splitext(h_file)[-1] != '.h':
            print 'C header file %s does not have extension .c'%h_file
            return

    for c_file, h_file in c_to_h.items():
        process_file(c_file, h_file)

if __name__ == '__main__':
    do_stuff(sys.argv[1:])

# vim: set tabstop=8 softtabstop=4 shiftwidth=4 expandtab:
