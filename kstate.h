/*
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is the KBUS State library.
 *
 * The Initial Developer of the Original Code is Kynesim, Cambridge UK.
 * Portions created by the Initial Developer are Copyright (C) 2013
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Kynesim, Cambridge UK
 *   Tony Ibbs <tibs@tonyibbs.co.uk>
 *
 * ***** END LICENSE BLOCK *****
 */

#ifndef _KSTATE_H_INCLUDED_
#define _KSTATE_H_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>

enum kstate_permissions {
  KSTATE_READ=1,          // The state may be read
  KSTATE_WRITE=2,         // The state may be written
};
typedef enum kstate_permissions kstate_permissions_t;

struct kstate_state {
  char        *name;
  uint32_t     permissions;
};
typedef struct kstate_state kstate_state_t;

struct kstate_transaction {
  struct kstate_state       state;

};
typedef struct kstate_transaction kstate_transaction_t;

// -------- TEXT AFTER THIS AUTOGENERATED - DO NOT EDIT --------
// Autogenerated by extract_hdrs.py on 2013-01-15 (Tue 15 Jan 2013) at 21:04
/*
 * Print a representation of 'state' on output 'stream'.
 *
 * Assumes the state is valid.
 *
 * If 'start' is non-NULL, print it before the state (with no added whitespace).
 * If 'eol' is true, then print a newline after the state.
 */
extern void print_state(FILE *stream, char *start, struct kstate_state *state, bool eol);

/*
 * Print a representation of 'transaction' on output 'stream'.
 *
 * Assumes the transaction is valid.
 *
 * If 'start' is non-NULL, print it before the transaction (with no added
 * whitespace).
 * If 'eol' is true, then print a newline after the transaction.
 */
extern void print_transaction(FILE *stream, char *start,
                              struct kstate_transaction *transaction, bool eol);

/*
 * Create a new "empty" state.
 *
 * The normal usage is to create an empty state and then immediately
 * populate it::
 *
 *     struct kstate_state *state = kstate_create_state();
 *     int ret = kstate_subscribe("State.Name", KSTATE_READ, state);
 *
 * and then eventually to destroy it:
 *
 *     int ret = kstate_unsubscribe(state);
 *     if (ret) {
 *       // deal with the error
 *     }
 *     kstate_destroy(&state);
 *
 * Returns the new state, or NULL if there was insufficient memory.
 */
extern struct kstate_state *kstate_create_state();

/*
 * Destroy a state created with 'kstate_create_state'.
 *
 * If a NULL pointer is given, then it is ignored, otherwise the state is
 * freed and the pointer 'state' is set to NULL.
 */
extern void kstate_free_state(struct kstate_state **state);

/*
 * Subscribe to a state.
 *
 * Any data that was previously in 'state' will be removed using
 * 'kstate_unsubscribe()'.
 *
 * - ``name`` is the name of the state to subscribe to.
 * - ``permissions`` is constructed by OR'ing the permission flags
 *   KSTATE_READ and/or KSTATE_WRITE. At least one of those must be given.
 * - ``state`` is the actual state identifier, as amended by this function.
 *
 * A state name may contain A-Z, a-z, 0-9 and the dot (.) character. It may not
 * start or end with a dot, and may not contain adjacent dots. It must contain
 * at least one character.
 *
 * If this is the first subscription to the named state, then the state will
 * be created.
 *
 * Returns 0 if the subscription succeeds, or a negative value if it fails.
 * The negative value will be ``-errno``, giving an indication of why the
 * function failed.
 */
extern int kstate_subscribe(struct kstate_state     *state,
                            const char              *name,
                            enum kstate_permissions  permissions);

/*
 * Unsubscribe from a state.
 *
 * - ``state`` is the state from which to unsubscribe.
 *
 * After this, the content of the state datastructure will have been
 * unset/freed. Unsubscribing from this same state value again will have no
 * effect.
 *
 * Note that transactions using the state keep their own copy of the state
 * information, and are not affected by this function - i.e., the state can
 * still be accessed via any transactions that are still open on it.
 *
 * Returns 0 if the unsubscription succeeds, or a negative value if it fails.
 * The negative value will be ``-errno``, giving an indication of why the
 * function failed.
 */
extern void kstate_unsubscribe(struct kstate_state   *state);

/*
 * Create a new "empty" transaction.
 *
 * The normal usage is to create an empty transaction and then immediately
 * populate it::
 *
 *     struct kstate_transaction *transaction = kstate_create_transaction();
 *     int ret = kstate_start_transaction(&transaction, state);
 *
 * and then eventually to destroy it:
 *
 *     int ret = kstate_unsubscribe(transaction);
 *     if (ret) {
 *       // deal with the error
 *     }
 *     kstate_destroy(&transaction);
 *
 * Returns the new transaction, or NULL if there was insufficient memory.
 */
extern struct kstate_transaction *kstate_create_transaction();

/*
 * Destroy a transaction created with 'kstate_create_transaction'.
 *
 * If a NULL pointer is given, then it is ignored, otherwise the transaction is
 * freed and the pointer 'transaction' is set to NULL.
 */
extern void kstate_free_transaction(struct kstate_transaction **transaction);

/*
 * Start a new transaction on a state.
 *
 * If 'transaction' was still active, it will first be aborted with
 * 'kstate_abort_transaction()'.
 *
 * * 'transaction' is the transaction to start.
 * * 'state' is the state on which to start the transaction.
 *
 * Returns 0 if starting the transaction succeeds, or a negative value if it
 * fails. The negative value will be ``-errno``, giving an indication of why
 * the function failed.
 */
extern int kstate_start_transaction(struct kstate_transaction *transaction,
                                    struct kstate_state       *state);

/*
 * Abort a transaction.
 *
 * - ``transaction`` is the transaction to abort.
 *
 * After this, the content of the transaction datastructure will have been
 * unset/freed. Unsubscribing from this same transaction value again will have
 * no effect.
 *
 * Returns 0 if the abort succeeds, or a negative value if it fails.
 * The negative value will be ``-errno``, giving an indication of why the
 * function failed.
 */
extern int kstate_abort_transaction(struct kstate_transaction  *transaction);

/*
 * Commit a transaction.
 *
 * - ``transaction`` is the transaction to commit.
 *
 * After this, the content of the transaction datastructure will have been
 * unset/freed.
 *
 * It is not allowed to commit a transaction that has not been started.
 * A transaction that has already been committed or aborted looks as if
 * it has not been started.
 *
 * Returns 0 if the commit succeeds, or a negative value if it fails.
 * The negative value will be ``-errno``, giving an indication of why the
 * function failed.
 */
extern int kstate_commit_transaction(struct kstate_transaction  *transaction);

// -------- TEXT BEFORE THIS AUTOGENERATED - DO NOT EDIT --------

#ifdef __cplusplus
}
#endif

#endif /* _KSTATE_H_INCLUDED_ */

// vim: set tabstop=8 softtabstop=2 shiftwidth=2 expandtab:
//
// Local Variables:
// tab-width: 8
// indent-tabs-mode: nil
// c-basic-offset: 2
// End:
